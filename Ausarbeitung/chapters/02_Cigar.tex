\chapter{CIGAR-Strings}

Ein Dateiformat, welches zur Speicherung von Alignments verwendet wird, ist das SAM-Format oder die binär komprimierte Version BAM. Dieses codiert ein Alignment in einem sogenannten CIGAR-String der aus einzelnen Zeichen besteht, die jeweils eine Edit-Operation bezeichnen, also M für eine Substitution, I für eine Insertion und D für eine Deletion. Gleiche aufeinanderfolgende Operationen werden als Kombination von Quantität und Symbol geschrieben.

Sei $u =$ \texttt{actgaact}, $v =$ \texttt{actagaat} und das Alignment $A = (a\rightarrow a, c\rightarrow c, t\rightarrow t, ...)$ gegeben.
\begin{center}
	\texttt{
		\begin{tabular}{ccccccccc}
			a & c & t & - & g & a & a & c & t\\
			$|$&$|$&$|$&&$|$&$|$&$|$& &$|$\\
			a&c&t&a&g&a&a& - &t
		\end{tabular}
	}
\end{center}
Ein Alignment wird üblicherweise in drei Zeilen geschrieben, wobei in der ersten Zeile die Sequenz $u$ und in der dritten Zeile die Sequenz $v$ geschrieben wird. In der mittleren Zeile symbolisiert das Zeichen '$|$' eine Substitution, wobei üblicherweise nur ein Match markiert wird. Außerdem wird ein $\varepsilon$ aus der Edit-Operation in diesem Fall durch das Zeichen '-' dargestellt.

Dieses Alignment wird duch den CIGAR-String \texttt{3M1I3M1D1M} repräsentiert. \cite{sam}.

\section{Komplexität}
%TODO
TODO
\clearpage

\section{Speicherverbrauch}\label{Cigar_Speicher}

\subsection{Entropie unabhängig vom Kodierungsverfahren}

\begin{figure}[h]
	\centering
	\includegraphics[width=12cm]{coding/cig_ent_einzel-1000-1000-d100}
	\caption{Entropie des CIGAR-Strings pro Symbol}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=12cm]{coding/cig_ent_faktor-1000-1000-d100}
	\caption{Entropie des CIGAR-Strings}
\end{figure}
\FloatBarrier
\subsection{Kodierung eines CIGAR-Strings}\label{Cigar_Beispiel}
Sei das Alignment $A$

\begin{verbatim}
0    5    0    5    0    5    0    5    0    
gagc-a-t-gttgcc-tggtcctttgctaggtactgta-gaga
|| | | | |  | | ||| |||| ||| ||| ||||| ||||
gaccaagtag--g-cgtggacctt-gctcggt-ctgtaagaga
0    5    0    5    0    5    0    5    0   
\end{verbatim}
gegeben, welches durch den CIGAR-String \texttt{4M1I1M1I1M1I1M2D1M1D1M1I8M\\1D7M1D5M1I4M} repräsentiert werden kann.

Im Folgenden vergleiche ich für diese Art der Alignment-Repräsentation die Verfahren der naiven binären Kodierung, der unären Kodierung und der Huffman-Kodierung.

Sei das Alphabet $\cal{A}$$_1$ $= \{$M, I, D$\}$, welches alle Symbole aus dem CIGAR-String enthält, das Alphabet $\cal{A}$$_2$ $= \{1, 2, 4, 5, 7, 8\}$, welches alle Zahlen aus dem CIGAR-String enthält, sowie die relativen Wahrscheinlichkeiten $p(c_1)$ jeden Symbols $c_1 \in$ $\cal{A}$$_1$ und $p(c_2)$ jeden Symbols $c_2 \in$ $\cal{A}$$_2$ gegeben.

\begin{table}[h]
	\centering
	\begin{tabular}{cccc}
		$c_1$&Häufigkeit&$p(c_1)$&\\
		\hline
		M & $10$ & $\frac{10}{38}$&\\
		I & $5$ & $\frac{5}{38}$&\\
		D & $4$ & $\frac{4}{38}$&\\
		&&&\\
		&&&\\
		&&&
	\end{tabular}\begin{tabular}{ccc}
	$c_2$&Häufigkeit&$p(c_2)$\\
	\hline
	$1$ & $13$ &$\frac{13}{38}$\\
	$4$ & $2$ & $\frac{2}{38}$\\
	$2$ & $1$ & $\frac{1}{38}$\\
	$5$ & $1$ & $\frac{1}{38}$\\
	$7$ & $1$ & $\frac{1}{38}$\\
	$8$ & $1$ & $\frac{1}{38}$
\end{tabular}
	\caption{Relative Wahrscheinlichkeiten CIGAR-String}
\end{table}

Bei einer naiven binären Kodierung wird jedes Symbol $c_i \in \cal{A}$$_i$ mit $\lceil \log_2n
 \rceil, n = |\cal{A}|$ Bit kodiert, also $\lceil \log_23\rceil + \lceil \log_26\rceil = 2 + 3 = 5$ Bit pro Symbol. Insgesamt ergibt das somit $19 \cdot 2 + 19 \cdot 3 = 95$ Bit.

Die unäre Kodierung kodiert jedes Symbol nach der Häufigkeit des Auftretens im Alphabet mit $i - 1$ $'1'$-Bits, gefolgt von einem $'0'$-Bit, wobei $i$ die Position des Symbols in einer nach der Häufigkeit absteigend sortierten Liste ist. Das am Häufigsten auftretende Symbol des Alphabets wird also mit $'0'$, das zweithäufigste mit $'10'$, das dritthäufigste mit $'110'$ usw. kodiert. \cite[S. 29-30]{coding}

Der oben genannte CIGAR-String wird demnach wie folgt unär kodiert:

\begin{table}[h]
	\centering
	\begin{tabular}{ccr}
		Symbol & Kodierung &  Anzahl Bits\\
		\hline
		M & $0$ & $10 \cdot 1 = 10$\\
		D & $10$ & $5 \cdot 2 = 10$\\
		I & $110$ & $4 \cdot 3 = 12$\\
		&&\\
		&&\\
		&&\\
		\hline
		\multicolumn{2}{l}{Gesamtanzahl:}&$32$
	\end{tabular}\begin{tabular}{ccr}
	Symbol & Kodierung &  Anzahl Bits\\
	\hline
	$1$ & $0$ & $13 \cdot 1 = 13$\\
	$4$ & $10$ & $2 \cdot 2 = \ \ 4$\\
	$2$ & $110$ & $1 \cdot 3 =\ \ 3$\\
	$5$ & $1110$ & $1 \cdot 4 =\ \ 4$\\
	$7$ & $11110$ & $1 \cdot 5 =\ \ 5$\\
	$8$ & $111110$ & $1 \cdot 6 =\ \ 6$\\
	\hline
	\multicolumn{2}{l}{}&$35$
\end{tabular}
	\caption{Unäre Kodierung des CIGAR-Strings}
\end{table}

Insgesamt benötigt die unäre Kodierung also $32 + 35 = 67$ Bit.

Der durchschnittliche Bitverbrauch für ein Symbol beträgt 
\[\frac{67}{38} \approx 1.76 \frac{\text{Bit}}{\text{Symbol}}\]

Bei einer \textit{minimalen} binären Kodierung, wie sie auch im Huffman-Alogrithmus verwendet wird, werden die Längen der Codewörter anhand der relativen Wahrscheinlichkeit des Symbols im Alphabet angepasst. Somit lässt sich eine Kodierung ermöglichen, welche im Durchschnitt weniger Bit pro Symbol beansprucht \cite[S. 53-57]{coding}. Eine sparsamere Variante des regulären Huffman-Algorithmus ist der Kanonische Huffman-Algorithmus, welcher im Gegensatz zu der ursprünglichen Variante eine eindeutige Menge von Codewörtern liefert und keinen vollständigen Huffman-Baum, sondern lediglich die Anzahl der Codewörter für jede vorhandene Codewortlänge, sowie die sortierten Symbole benötigt, um die Informationen zu dekodieren. %TODO cite und für Beispiele anwenden

Der Huffman-Algorithmus würde bei dem oben genannten Beispiel des CIGAR-Strings wie folgt ablaufen:

Ausführung des Huffman-Algorithmus ergibt nach \cite[S. 54]{coding}:
\FloatBarrier
\begin{table}[h]
	\centering
	\begin{tabular}{ccr}
		Symbol & Kodierung & Anzahl Bits\\
		\hline
		M & $0$ & $10 \cdot 1 = 10$\\
		D & $10$ & $5 \cdot 2 = 10$\\
		I & $11$ & $4 \cdot 2 =\ \ 8$\\
		&&\\
		&&\\
		&&\\
		\hline
		\multicolumn{2}{l}{Gesamtanzahl:}&$28$
	\end{tabular}\begin{tabular}{ccr}
	Symbol & Kodierung & Anzahl Bits\\
	\hline
	$1$ & $00$ & $13 \cdot 2 = 26$\\
	$4$ & $01$ & $2 \cdot 2 =\ \ 4$\\
	$2$ & $100$ & $1 \cdot 3 =\ \ 3$\\
	$5$ & $101$ & $1 \cdot 3 =\ \ 3$\\
	$7$ & $110$ & $1 \cdot 3 =\ \ 3$\\
	$8$ & $111$ & $1 \cdot 3 =\ \ 3$\\
	\hline
	\multicolumn{2}{l}{}&$42$
\end{tabular}
	\caption{Huffmann-Kodierung des CIGAR-Strings}
\end{table}
\FloatBarrier
und die dazugehörigen Huffman-Bäume:

\begin{figure}[h]
	\centering
	\begin{forest}
		for tree={grow'=south}
		[$\frac{19}{38}$
		[$\frac{9}{38}$, edge label={node[midway,right,font=\scriptsize]{1}}
		[I, edge label={node[midway,right,font=\scriptsize]{1}}]
		[D, edge label={node[midway,left,font=\scriptsize]{0}}] ] 
		[M, edge label={node[midway,left,font=\scriptsize]{0}}] ]
		]
	\end{forest}
	\begin{forest}
	for tree={grow'=south}
	[$\frac{19}{38}$
	[$\frac{4}{38}$, edge label={node[midway,right,font=\scriptsize]{1}}
	[$\frac{2}{38}$, edge label={node[midway,right,font=\scriptsize]{1}}
	[$8$, edge label={node[midway,right,font=\scriptsize]{1}}]
	[$7$, edge label={node[midway,left,font=\scriptsize]{0}}]]
	[$\frac{2}{38}$, edge label={node[midway,left,font=\scriptsize]{0}}
	[$5$, edge label={node[midway,right,font=\scriptsize]{1}}]
	[$2$, edge label={node[midway,left,font=\scriptsize]{0}}] ]]
	[$\frac{15}{38}$, edge label={node[midway,left,font=\scriptsize]{0}} 
	[$4$, edge label={node[midway,right,font=\scriptsize]{1}}]
	[$1$, edge label={node[midway,left,font=\scriptsize]{0}}] ]
	]
\end{forest}
	\caption{Huffman-Bäume der Kodierung des CIGAR-Strings}
\end{figure}

Der gesamte Bitverbrauch dieser Kodierung ist demnach $28 + 42 = 70$ Bit.

Der durchschnittliche Bitverbrauch für ein Symbol beträgt 
\[\frac{70}{38} \approx 1.84 \frac{\text{Bit}}{\text{Symbol}}\]

\subsection{Testläufe}\label{Cigar_Testläufe}

Die folgenden Grafiken wurden mit jeweils 10.000 zufällig generierte Sequenzpaaren mit je etwa 1.000 Basen, einer Fehlerrate von 15\% und einem $\Delta$-Wert von 100 berechnet.

\begin{figure}[h]
	\centering
	\includegraphics[width=12cm]{coding/cig-bin-10000-1000-d100}
	\caption{Bitverbrauch der binären Kodierung des CIGAR-Strings}\label{fig:cig-bin}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=12cm]{coding/cig-una-10000-1000-d100}
	\caption{Bitverbrauch der unären Kodierung des CIGAR-Strings}\label{fig:cig-una}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=12cm]{coding/cig-huf-10000-1000-d100}
	\caption{Bitverbrauch der Huffman-Kodierung des CIGAR-Strings}\label{fig:cig-huf}
\end{figure}

\section{Bewertung}

Die Abbildungen \ref{fig:cig-bin} und \ref{fig:cig-una} verdeutlichen, dass die binäre und unäre Kodierung deutliche Schwankungen im Bitverbrauch aufweisen, welche sich durch die zufällig generierten Sequenzpaare erklären lassen, deren Alignments unter Umständen sehr viele oder ausschließlich Matches bzw. sehr viele InDels aufweisen können. Die Abbildung \ref{fig:cig-huf} hingegen weist eine Normalverteilung des Bitverbrauchs für die Huffman-Kodierung auf.
Im Mittel benötigt die naive binäre Kodierung $284.60$ Bit, die unäre Kodierung $264.84$ Bit und die Huffman-Kodierung $162.93$ Bit.

In den dargestellten Testläufen verbraucht die Huffman-Kodierung somit durchschnittlich mit Abstand am wenigsten Speicher, obwohl in dem unter \ref{Cigar_Beispiel} beschriebenen Beispiel die unäre Kodierung den CIGAR-String etwas effizienter kodiert. Der Grund hierfür ist die deutlich höhere Fehlerrate in \ref{Cigar_Beispiel}, welche die Anzahl der zu kodierenden Symbole deutlich erhöht.

Das CIGAR-Format benötigt folglich wenig Speicher für Alignments mit einer kleinen Edit-Distanz und deutlich mehr Speicher für Alignments mit einer großen Edit-Distanz, da in diesem Fall eine höhere Anzahl unterschiedlicher Symbole kodiert werden muss.