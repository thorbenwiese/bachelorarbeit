%
% Einleitung
%

\chapter{TracePoint Konzept}

Ein neuer Ansatz der speichereffizienten Repräsentation von Alignments wurde von Gene Myers in \cite{myers} beschrieben und basiert auf dem Konzept der Trace Points.

Sei $A$ ein Alignment von $u[i...j]$ und $v[k...\ell]$ mit $i < j$ und $k < l$ und sei $\Delta \in \mathbb{N}$. Sei $p = \left \lceil\frac{i}{\Delta}\right \rceil$. Man unterteilt $u[i...j]$ in $\tau = \left \lceil\frac{j}{\Delta}\right \rceil - \left \lfloor\frac{i}{\Delta}\right \rfloor$ Substrings $u_0, u_1, ... , u_{\tau -1}$ mit
\[  
u_q =
\begin{cases} 
u[i...p\cdot\Delta] & \text{falls }q = 0 \\
u[(p+q-1)\cdot\Delta+1...(p+q)\cdot\Delta] & \text{falls }0<q<\tau -1\\
u[(p+\tau-2)\cdot\Delta...j] & \text{falls }q = \tau -1
\end{cases}
\]

Für alle $q$ mit $ 0 \leq q < \tau -1$ sei $t_q$ der letzte Index des Substrings von $v$, der in A mit $u_q$ aligniert. $t_q$ nennt man Trace Point. Für $q = 0$ aligniert $u_0$ mit $v_0 = v[k...t_0]$. Für alle $q$ mit $0<q< \tau -1$ aligniert $u_q$ mit $v_q = v[t_{q-1}+1...t_q]$.

Seien $i,j,k,\ell,\Delta$ und die Trace-Points eines Alignments von $u$ und $v$ gegeben. Dann kann ein Alignment $A'$ von $u$ und $v$ mit $\delta (A') \leq \delta (A)$ konstruiert werden. Danach bestimmt man aus den Trace-Points die Substring-Paare $u_q$ und $v_q$, berechnet hierfür ein optimales Alignment und konkateniert die Alignments von den aufeinanderfolgenden Substring-Paaren zu $A'$.

Beispiel 2:
\begin{verbatim}
Sequenz 1: gagcatgttgcctggtcctttgctaggtactgtagaga
Sequenz 2: gaccaagtaggcgtggaccttgctcggtctgtaagaga
Delta: 15

Gesamtalignment:

0    5    0    5    0    5    0    5    0    
gagc-a-t-gttgcc-tggtcctttgctaggtactgta-gaga
|| | | | |  | | ||| |||| ||| ||| ||||| ||||
gaccaagtag--g-cgtggacctt-gctcggt-ctgtaagaga
0    5    0    5    0    5    0    5    0    



seq1[0...14] aligniert mit seq2[0...15]
gagc-a-t-gttgcc-tgg
|| | | | |  | | |||
gaccaagtag--g-cgtgg

seq1[15...29] aligniert mit seq2[16...28]
tcctttgctaggtac
 |||| ||| ||| |
acctt-gctcggt-c

seq1[30...37] aligniert mit seq2[29...37]
tgta-gaga
|||| ||||
tgtaagaga

Trace Points: [15, 28] 

Berechnung der Intervalle anhand der Trace Points:

seq1[0...14] aligniert mit seq2[0...15]
gagc-a-t-gttgcc-tgg
|| | | | |  | | |||
gaccaagtag--g-cgtgg

seq1[15...29] aligniert mit seq2[16...28]
tcctttgctaggtac
 |||| ||| ||| |
acctt-gctcggt-c

seq1[30...37] aligniert mit seq2[29...37]
tgta-gaga
|||| ||||
tgtaagaga


0    5    0    5    0    5    0    5    0    
gagc-a-t-gttgcc-tggtcctttgctaggtactgta-gaga
|| | | | |  | | ||| |||| ||| ||| ||||| ||||
gaccaagtag--g-cgtggacctt-gctcggt-ctgtaagaga
0    5    0    5    0    5    0    5    0    
\end{verbatim}

\section{Komplexität}

%TODO ausführlicher
 Für die Trace-Point Repräsentation wird für eine Edit-Distanz $e$ mit Einheitskosten als Kostenfunktion $\delta$ wie oben beschrieben lediglich $O(e^2)$ Zeit pro Teilalignment benötigt, wobei bei einer erwarteten Fehlerrate $\varepsilon$ des Alignments die Edit-Distanz immer höchstens so groß ist wie die Anzahl der Fehler im Teilalignment. \cite[S.41-42]{gsa-skript}
 
\section{Speicherverbrauch}
\subsection{Beispiel}
Sei $\Delta = 5$ und das Alignment $A$
\begin{verbatim}
		0    5    0    5    0    5    0    5    0    
		gagc-a-t-gttgcc-tggtcctttgctaggtactgta-gaga
		|| | | | |  | | ||| |||| ||| ||| ||||| ||||
		gaccaagtag--g-cgtggacctt-gctcggt-ctgtaagaga
		0    5    0    5    0    5    0    5    0   
\end{verbatim}

wie in Abschnitt \ref{Cigar_Speicher} mit den dazugehörigen TracePoints $5, 10, 15, 20, 24, 28$ und $34$ gegeben. Es ergibt sich somit das Alphabet $\cal{A}$ $= \{5, 10, 15, 20, 24, 28, 34\}$.
 %TODO alle Kodierungen für Delta-Coding, nicht für normale TracePoints
Mit einer naiven binären Kodierung bräuchte man demnach für jedes Symbol $c \in \cal{A}$ $\left \lceil \log_2(7) \right \rceil = 3$ Bit pro Symbol, also $7 \cdot 3 = 21$ Bit insgesamt.

%TODO unäre Kodierung

Die Repräsentation des Alignments $A$ benötigt als CIGAR-String mit einer naiven binären Kodierung $228$ Bit und als unäre Kodierung XX Bit, wobei die Kodierung der Trace Points mit $\Delta = 5$ mit einer naiven binären Kodierung $21$ Bit und als unäre Kodierung XX Bit benötigt.

Es ist somit zu erkennen, dass die Kodierung der Trace Points in diesem Fall mit einem relativ klein gewählten $\Delta$ weniger Speicher benötigt, als die Kodierung des CIGAR-Strings. Dennoch hängt der Speicherverbrauch der Trace Points Kodierung von der Wahl des $\Delta$ ab, da bei einem kleinen $\Delta$ mehr Trace Points und somit Symbole gespeichert werden müssen, als bei einem großen $\Delta$ und kann somit bei einer sehr ungünstig gewählten Größe mehr Speicher verbrauchen als ein CIGAR-String.

\subsection{Delta-Kodierung}

\subsection{Testläufe}

Die folgenden Grafiken wurden mit jeweils 100 zufällig generierte Sequenzpaare mit je 200 Basen, einer Fehlerrate von 15\% und einem $\Delta$-Wert von 10 berechnet.

Delta plus Trace Points

\begin{filecontents*}{differences_binary.txt}
	1 90
	2 90
	3 90
	4 90
	5 90
	6 90
	7 90
	8 90
	9 90
	10 90
	11 90
	12 90
	13 90
	14 90
	15 90
	16 90
	17 90
	18 90
	19 90
	20 90
	21 90
	22 90
	23 90
	24 90
	25 90
	26 90
	27 90
	28 90
	29 90
	30 90
	31 90
	32 90
	33 90
	34 90
	35 90
	36 90
	37 90
	38 90
	39 90
	40 90
	41 90
	42 90
	43 90
	44 90
	45 90
	46 90
	47 90
	48 90
	49 90
	50 90
	51 90
	52 90
	53 90
	54 90
	55 90
	56 90
	57 90
	58 90
	59 90
	60 90
	61 90
	62 90
	63 90
	64 90
	65 90
	66 90
	67 90
	68 90
	69 90
	70 90
	71 90
	72 90
	73 90
	74 90
	75 90
	76 90
	77 90
	78 90
	79 90
	80 90
	81 90
	82 90
	83 90
	84 90
	85 90
	86 90
	87 90
	88 90
	89 90
	90 90
	91 90
	92 90
	93 90
	94 90
	95 90
	96 90
	97 90
	98 90
	99 90
	100 90
\end{filecontents*}

\begin{filecontents*}{differences_huffman.txt}
	1 2
	2 5
	3 5
	4 5
	5 5
	6 5
	7 5
	8 9
	9 9
	10 5
	11 5
	12 5
	13 5
	14 5
	15 5
	16 9
	17 5
	18 9
	19 5
	20 5
	21 5
	22 5
	23 9
	24 9
	25 5
	26 5
	27 9
	28 5
	29 5
	30 5
	31 5
	32 9
	33 5
	34 9
	35 2
	36 5
	37 9
	38 5
	39 5
	40 5
	41 5
	42 5
	43 5
	44 9
	45 5
	46 5
	47 5
	48 5
	49 5
	50 9
	51 9
	52 5
	53 5
	54 5
	55 2
	56 14
	57 5
	58 2
	59 9
	60 2
	61 5
	62 5
	63 9
	64 9
	65 5
	66 5
	67 9
	68 5
	69 5
	70 5
	71 5
	72 5
	73 14
	74 2
	75 9
	76 5
	77 9
	78 2
	79 5
	80 14
	81 5
	82 9
	83 5
	84 5
	85 14
	86 9
	87 5
	88 5
	89 9
	90 2
	91 5
	92 9
	93 5
	94 9
	95 5
	96 5
	97 5
	98 5
	99 5
	100 5
\end{filecontents*}

\begin{filecontents*}{differences_unary.txt}
	1 21
	2 24
	3 29
	4 25
	5 22
	6 25
	7 28
	8 31
	9 26
	10 25
	11 20
	12 21
	13 27
	14 25
	15 30
	16 22
	17 23
	18 23
	19 29
	20 28
	21 23
	22 24
	23 23
	24 29
	25 24
	26 22
	27 23
	28 22
	29 22
	30 25
	31 25
	32 26
	33 21
	34 24
	35 28
	36 23
	37 23
	38 19
	39 26
	40 23
	41 27
	42 23
	43 25
	44 25
	45 24
	46 22
	47 24
	48 19
	49 25
	50 25
	51 28
	52 21
	53 20
	54 23
	55 25
	56 24
	57 27
	58 25
	59 28
	60 22
	61 27
	62 22
	63 26
	64 21
	65 26
	66 23
	67 26
	68 29
	69 26
	70 28
	71 26
	72 21
	73 25
	74 26
	75 28
	76 28
	77 23
	78 27
	79 21
	80 26
	81 33
	82 25
	83 24
	84 32
	85 25
	86 25
	87 21
	88 27
	89 23
	90 27
	91 29
	92 30
	93 25
	94 21
	95 22
	96 27
	97 25
	98 31
	99 24
	100 23
\end{filecontents*}

\begin{center}
	\begin{tikzpicture}
	\begin{axis}[
	title={Bitverbrauch der naiven binären Kodierung für die Delta-Kodierung},			
	xlabel={Anzahl Durchläufe},
	ylabel={Anzahl Bits}]
	\addplot table {differences_binary.txt};
	\end{axis}
	\end{tikzpicture}
	
	\begin{tikzpicture}
	\begin{axis}[
	title={Bitverbrauch der unären binären Kodierung für die Delta-Kodierung},			
	xlabel={Anzahl Durchläufe},
	ylabel={Anzahl Bits}]
	\addplot table {differences_unary.txt};
	\end{axis}
	\end{tikzpicture}
	
	\begin{tikzpicture}
	\begin{axis}[
	title={Bitverbrauch der Huffman-Kodierung für die Delta-Kodierung},			
	xlabel={Anzahl Durchläufe},
	ylabel={Anzahl Bits}]
	\addplot table {differences_huffman.txt};
	\end{axis}
	\end{tikzpicture}
	
	\begin{tikzpicture}
	\begin{axis}[
	title={Bitverbrauch von unärer und Huffman-Kodierung für die Delta-Kodierung},			
	xlabel={Anzahl Durchläufe},
	ylabel={Anzahl Bits}]
	\addplot table {differences_unary.txt};
	\addlegendentry{Unäre Kodierung};
	\addplot table {differences_huffman.txt};
	\addlegendentry{Huffman-Kodierung};
	\end{axis}
	\end{tikzpicture}
\end{center}

\section{Bewertung}
Je größer der vorher definierte positive Parameter $\Delta$ ist, desto weniger Trace-Points werden gespeichert und umso länger dauert die Berechnung, um die Teil-Alignments zu rekonstruieren. Bei einem kleinen $\Delta$ werden analog mehr Trace-Points gespeichert, aber die Rekonstruktionszeit der Teil-Alignments ist geringer.

Mithilfe von $\Delta$ lässt sich somit ein Trade-Off zwischen dem Speicherplatzverbrauch und dem Zeitbedarf für die Rekonstruktion der Teil-Alignments einstellen.
