\chapter{TracePoint Konzept}

Ein neuer Ansatz der speichereffizienten Repräsentation von Alignments wurde von Gene Myers in \cite{myers} beschrieben und basiert auf dem Konzept der Trace Points.

Sei $A$ ein Alignment von $u[i...j]$ und $v[k...\ell]$ mit $i < j$ und $k < l$ und sei $\Delta \in \mathbb{N}$. Sei $p = \left \lceil\frac{i}{\Delta}\right \rceil$. Man unterteilt $u[i...j]$ in $\tau = \left \lceil\frac{j}{\Delta}\right \rceil - \left \lfloor\frac{i}{\Delta}\right \rfloor$ Substrings $u_0, u_1, ... , u_{\tau -1}$ mit
\[  
u_q =
\begin{cases} 
u[i...p\cdot\Delta] & \text{falls }q = 0 \\
u[(p+q-1)\cdot\Delta+1...(p+q)\cdot\Delta] & \text{falls }0<q<\tau -1\\
u[(p+\tau-2)\cdot\Delta...j] & \text{falls }q = \tau -1
\end{cases}
\]

Für alle $q$ mit $ 0 \leq q < \tau -1$ sei $t_q$ der letzte Index des Substrings von $v$, der in A mit $u_q$ aligniert. $t_q$ nennt man Trace Point. Für $q = 0$ aligniert $u_0$ mit $v_0 = v[k...t_0]$. Für alle $q$ mit $0<q< \tau -1$ aligniert $u_q$ mit $v_q = v[t_{q-1}+1...t_q]$.

Seien $i,j,k,\ell,\Delta$ und die Trace-Points eines Alignments von $u$ und $v$ gegeben. Dann kann ein Alignment $A'$ von $u$ und $v$ mit $\delta (A') \leq \delta (A)$ konstruiert werden. Danach bestimmt man aus den Trace-Points die Substring-Paare $u_q$ und $v_q$, berechnet hierfür ein optimales Alignment und konkateniert die Alignments von den aufeinanderfolgenden Substring-Paaren zu $A'$.

Beispiel:
\begin{verbatim}
Sequenz 1: gagcatgttgcctggtcctttgctaggtactgtagaga
Sequenz 2: gaccaagtaggcgtggaccttgctcggtctgtaagaga
Delta: 15

Gesamtalignment:

0    5    0    5    0    5    0    5    0    
gagc-a-t-gttgcc-tggtcctttgctaggtactgta-gaga
|| | | | |  | | ||| |||| ||| ||| ||||| ||||
gaccaagtag--g-cgtggacctt-gctcggt-ctgtaagaga
0    5    0    5    0    5    0    5    0    



seq1[0...14] aligniert mit seq2[0...15]
gagc-a-t-gttgcc-tgg
|| | | | |  | | |||
gaccaagtag--g-cgtgg

seq1[15...29] aligniert mit seq2[16...28]
tcctttgctaggtac
 |||| ||| ||| |
acctt-gctcggt-c

seq1[30...37] aligniert mit seq2[29...37]
tgta-gaga
|||| ||||
tgtaagaga

Trace Points: [15, 28] 
\end{verbatim}

\section{Komplexität}

TODO

%TODO ausführlicher
 Für die Trace-Point Repräsentation wird für eine Edit-Distanz $e$ mit Einheitskosten als Kostenfunktion $\delta$ wie oben beschrieben lediglich $O(e^2)$ Zeit pro Teilalignment benötigt, wobei bei einer erwarteten Fehlerrate $\varepsilon$ des Alignments die Edit-Distanz immer höchstens so groß ist wie die Anzahl der Fehler im Teilalignment. \cite[S.41-42]{gsa-skript}
 
\section{Speicherverbrauch}

\subsection{Differenzen-Kodierung}\label{Differenzen-Kodierung}

%TODO Quellen
Gegeben sei eine Liste $L = (a_1, a_2, ... , a_n)$ mit $a_i < a_{i+1}, 0 < i \leq n$.

Anstatt jeden Wert $a \in L$ als solchen abzuspeichern, kann alternativ die Differenz eines Wertes $a_i$ zu dem nachfolgenden Wert $a_{i+1}$ abgespeichert werden. Lediglich der erste (oder letzte) Wert aus $L$ wird benötigt, um später sukzessive die ursprüngliche Liste rekonstruieren zu können.
\[L_{diff} = (a_1, (a_2-a_1), (a_3-a_2), ... , (a_{n}-a_{n-1}))\]

Bei gleichmäßig ansteigenden Werten ist die Abweichung der Differenzen zweier aufeinanderfolgender Werte in  der Liste untereinander gering und die Menge der zu kodierenden Symbole verringert sich.

\subsection{Kodierung der Trace Point Differenzen}
Sei $\Delta = 5$ und das Alignment $A$
\begin{verbatim}
		0    5    0    5    0    5    0    5    0    
		gagc-a-t-gttgcc-tggtcctttgctaggtactgta-gaga
		|| | | | |  | | ||| |||| ||| ||| ||||| ||||
		gaccaagtag--g-cgtggacctt-gctcggt-ctgtaagaga
		0    5    0    5    0    5    0    5    0   
\end{verbatim}

wie in Abschnitt \ref{Cigar_Speicher} mit den dazugehörigen TracePoints $5, 10, 15, 20, 24, 28$ und $34$ gegeben. Es ergibt sich somit das Alphabet $\cal{A}$ $= \{5, 10, 15, 20, 24, 28, 34\}$ mit ausschließlich positiven und aufsteigenden Werten.

Für die Trace Point Darstellung ist somit eine Differenzen-Kodierung möglich. Als neue Liste zu kodierender Werte ergibt sich nach \ref{Differenzen-Kodierung} $L_{diff} = (5, 5, 5, 5, 4, 4, 6)$.

Um aus den Trace Points ein neues Alignment rekonstruieren zu können, benötigt man zusätzlich mindestens den $\Delta$-Wert, damit die Grenzen der Substrings beider Sequenzen berechnet werden können. Hierfür muss also der $\Delta$-Wert zu $L$ hinzugefügt werden.

Für das oben genannten Beispiel ergibt sich somit $L_\Delta = (5, 5, 5, 5, 5, 4, 4, 6)$.

Sei das Alphabet $\cal{A}$ $= \{4, 5, 6\}$ für $L_\Delta$, sowie die relativen Wahrscheinlichkeiten $p(c)$ jeden Symbols $c \in$ $\cal{A}$ gegeben. 

\begin{table}[h]
	\centering
	\begin{tabular}{ccc}
		$c$&Häufigkeit&$p(c)$\\
		\hline
		$5$ & $5$ & $\frac{5}{8}$\\
		$4$ & $2$ & $\frac{2}{8}$\\
		$6$ & $1$ & $\frac{1}{8}$
	\end{tabular}
	\caption{Relative Wahrscheinlichkeiten der Delta-Kodierung}
\end{table}

Bei der naiven binären Kodierung ergibt sich analog zu \ref{Cigar_Speicher} ein Bedarf von $\lceil \log_28\rceil = 3$ Bit pro Symbol, also $8 \cdot 3 = 24$ Bit insgesamt.

Die unäre Kodierung ergibt für dieses Beispiel die folgende Kodierung:

\begin{table}[h]
	\centering
	\begin{tabular}{ccr}
		Symbol & Kodierung &  Anzahl Bits\\
		\hline
		$5$ & $0$ & $5 \cdot 1 = 5$\\
		$4$ & $10$ & $2 \cdot 2 = 4$\\
		$6$ & $110$ & $1 \cdot 3 = 3$\\
		\hline
		\multicolumn{2}{l}{Gesamtanzahl:}&$12$
	\end{tabular}
	\caption{Unäre Kodierung der Delta-Kodierung}
\end{table}

Insgesamt benötigt die unäre Kodierung also $12$ Bit mit einem durchschnittlichen Verbrauch pro  Symbol von
\[\frac{12}{8} \approx 1.5 \frac{\text{Bit}}{\text{Symbol}}\]

Die Ausführung des Huffman-Algorithmus ergibt nach \cite[S. 54]{coding}:

\begin{table}[h]
	\centering
	\begin{tabular}{ccr}
		Symbol & Kodierung & Anzahl Bits\\
		\hline
		$5$ & $0$ & $5 \cdot 1 = 5$\\
		$4$ & $10$ & $2 \cdot 2 = 4$\\
		$6$ & $11$ & $1 \cdot 2 = 2$\\
		\hline
		\multicolumn{2}{l}{Gesamtanzahl:}&$11$
	\end{tabular}
	\caption{Huffman-Kodierung der Delta-Kodierung}
\end{table}

\FloatBarrier

und der dazugehörige Huffman-Baum:

\begin{figure}[h]
	\centering
	\begin{forest}
		for tree={grow'=south}
		[$\frac{8}{8}$
		[$\frac{3}{8}$, edge label={node[midway,right,font=\scriptsize]{1}}
		[$6$, edge label={node[midway,right,font=\scriptsize]{1}}]
		[$4$, edge label={node[midway,left,font=\scriptsize]{0}}]]
		[$5$, edge label={node[midway,left,font=\scriptsize]{0}}]
		]
	\end{forest}
	\caption{Huffman-Baum der Delta-Kodierung}
\end{figure}

Der gesamte Bitverbrauch der Huffman-Kodierung ist demnach $11$ Bit mit einem durchschnittlichen Verbrauch pro Symbol von 
\[\frac{11}{8} \approx 1.38 \frac{\text{Bit}}{\text{Symbol}}\]

\subsection{Testläufe}

Die folgenden Grafiken wurden mit jeweils 100 zufällig generierte Sequenzpaaren mit je etwa 200 Basen, einer Fehlerrate von 15\% und einem $\Delta$-Wert von 10 berechnet.

\begin{filecontents*}{differences_binary.txt}
	1 95
	2 95
	3 95
	4 95
	5 95
	6 95
	7 95
	8 95
	9 95
	10 95
	11 95
	12 95
	13 95
	14 95
	15 95
	16 95
	17 95
	18 95
	19 95
	20 95
	21 95
	22 95
	23 95
	24 95
	25 95
	26 95
	27 95
	28 95
	29 95
	30 95
	31 95
	32 95
	33 95
	34 95
	35 95
	36 95
	37 95
	38 95
	39 95
	40 95
	41 95
	42 95
	43 95
	44 95
	45 95
	46 95
	47 95
	48 95
	49 95
	50 95
	51 95
	52 95
	53 95
	54 95
	55 95
	56 95
	57 95
	58 95
	59 95
	60 95
	61 95
	62 95
	63 95
	64 95
	65 95
	66 95
	67 95
	68 95
	69 95
	70 95
	71 95
	72 95
	73 95
	74 95
	75 95
	76 95
	77 95
	78 95
	79 95
	80 95
	81 95
	82 95
	83 95
	84 95
	85 95
	86 95
	87 95
	88 95
	89 95
	90 95
	91 95
	92 95
	93 95
	94 95
	95 95
	96 95
	97 95
	98 95
	99 95
	100 95
\end{filecontents*}

\begin{filecontents*}{differences_huffman.txt}
	1 5
	2 5
	3 5
	4 5
	5 5
	6 9
	7 5
	8 5
	9 5
	10 5
	11 5
	12 2
	13 5
	14 5
	15 2
	16 5
	17 5
	18 9
	19 5
	20 5
	21 14
	22 5
	23 5
	24 5
	25 9
	26 5
	27 9
	28 5
	29 2
	30 5
	31 14
	32 5
	33 5
	34 5
	35 5
	36 5
	37 5
	38 5
	39 5
	40 5
	41 5
	42 9
	43 5
	44 5
	45 2
	46 9
	47 5
	48 5
	49 9
	50 5
	51 9
	52 5
	53 5
	54 5
	55 9
	56 5
	57 5
	58 9
	59 2
	60 5
	61 5
	62 5
	63 5
	64 5
	65 5
	66 9
	67 2
	68 9
	69 9
	70 5
	71 2
	72 2
	73 9
	74 5
	75 5
	76 9
	77 5
	78 9
	79 2
	80 5
	81 5
	82 5
	83 5
	84 5
	85 9
	86 9
	87 9
	88 9
	89 5
	90 9
	91 5
	92 5
	93 5
	94 5
	95 5
	96 5
	97 5
	98 9
	99 5
	100 9
\end{filecontents*}

\begin{filecontents*}{differences_unary.txt}
	1 26
	2 28
	3 24
	4 23
	5 22
	6 27
	7 22
	8 23
	9 29
	10 20
	11 24
	12 23
	13 20
	14 26
	15 25
	16 23
	17 26
	18 23
	19 25
	20 30
	21 27
	22 26
	23 24
	24 25
	25 25
	26 26
	27 28
	28 28
	29 26
	30 24
	31 23
	32 23
	33 27
	34 25
	35 26
	36 36
	37 24
	38 25
	39 24
	40 21
	41 29
	42 22
	43 31
	44 30
	45 26
	46 26
	47 28
	48 27
	49 25
	50 25
	51 26
	52 32
	53 31
	54 23
	55 26
	56 29
	57 26
	58 29
	59 24
	60 30
	61 25
	62 32
	63 27
	64 24
	65 28
	66 23
	67 28
	68 23
	69 25
	70 23
	71 25
	72 22
	73 23
	74 28
	75 27
	76 25
	77 24
	78 23
	79 25
	80 25
	81 27
	82 32
	83 27
	84 27
	85 23
	86 31
	87 23
	88 21
	89 24
	90 21
	91 27
	92 31
	93 23
	94 25
	95 34
	96 26
	97 28
	98 26
	99 29
	100 28
\end{filecontents*}

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
	\begin{axis}[
	xlabel={Anzahl Durchläufe},
	ylabel={Anzahl Bits},
	legend style={at={(0.5,-0.15)},anchor=north},
	xtick={0,10,20,...,100},
	ytick={80,90,100,110,120}]
	\addplot table {coding/differences_binary.txt};
	\addlegendentry{Binäre Kodierung};
	\end{axis}
	\end{tikzpicture}
	\caption{Bitverbrauch der naiven binären Kodierung der Delta-Kodierung}\label{fig:diff-bin}
\end{figure}

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
	\begin{axis}[
	xlabel={Anzahl Durchläufe},
	ylabel={Anzahl Bits},
	legend style={at={(0.5,-0.15)},anchor=north},
	xtick={0,10,20,...,100},
	ytick={0,20,22,24,...,38}]
	\addplot table {coding/differences_unary.txt};
	\addplot [dashed, color=red, thick] coordinates {
		(0,27) (105,27)
	};
	\addlegendentry{Unäre Kodierung};
	\addlegendentry{Mittelwert};
	\end{axis}
	\end{tikzpicture}
	\caption{Bitverbrauch der unären Kodierung der Delta-Kodierung}\label{fig:diff-una}
\end{figure}
	
\begin{figure}[h]
	\centering
	\begin{tikzpicture}
	\begin{axis}[
	xlabel={Anzahl Durchläufe},
	ylabel={Anzahl Bits},
	legend style={at={(0.5,-0.15)},anchor=north},
	xtick={0,10,20,...,100},
	ytick={0,2,4,6,...,18}]
	\addplot table {coding/differences_huffman.txt};
	\addplot [dashed, color=red, thick] coordinates {
		(0,5) (105,5)
	};
	\addlegendentry{Huffman-Kodierung};
	\addlegendentry{Mittelwert};
	\end{axis}
	\end{tikzpicture}
	\caption{Bitverbrauch der Huffman-Kodierung der Delta-Kodierung}\label{fig:diff-huf}
\end{figure}
	
\begin{figure}[h]
	\centering
	\begin{tikzpicture}
	\begin{axis}[
	xlabel={Anzahl Durchläufe},
	ylabel={Anzahl Bits},
	legend style={at={(0.5,-0.15)},anchor=north},
	xtick={0,10,20,...,100},
	ytick={0,20,30,...,100}]
	\addplot table {coding/differences_binary.txt};
	\addlegendentry{Binäre Kodierung};
	\addplot table {coding/differences_unary.txt};
	\addlegendentry{Unäre Kodierung};
	\addplot [dashed, color=red, thick] coordinates {
		(0,27) (105,27)
	};
	\addlegendentry{Mittelwert unäre Kodierung};
	\end{axis}
	\end{tikzpicture}
	\caption{Binäre und unäre Kodierung der Delta-Kodierung}\label{fig:diff-bin-una}
\end{figure}
	
\begin{figure}[h]
	\centering
	\begin{tikzpicture}
	\begin{axis}[
	xlabel={Anzahl Durchläufe},
	ylabel={Anzahl Bits},
	legend style={at={(0.5,-0.15)},anchor=north},
	xtick={0,10,20,...,100},
	ytick={0,5,10,15,20,...,40}]
	\addplot table {coding/differences_unary.txt};
	\addlegendentry{Unäre Kodierung};
	\addplot table {coding/differences_huffman.txt};
	\addlegendentry{Huffman-Kodierung};
	\addplot [dashed, color=blue, thick] coordinates {
		(0,27) (105,27)
	};
	\addplot [dashed, color=red, thick] coordinates {
		(0,5) (105,5)
	};
	\addlegendentry{Mittelwert unäre Kodierung};
	\addlegendentry{Mittelwert Huffman-Kodierung};
	\end{axis}
	\end{tikzpicture}
	\caption{Unäre und Huffman-Kodierung der Delta-Kodierung}\label{fig:diff-una-huf}
\end{figure}

\section{Bewertung}

Die naive binäre Kodierung benötigt, wie in Abbildung \ref{fig:diff-bin} dargestellt, in jedem Durchlauf und somit auch im Mittel konstant $100$ Bit, da für jeden Durchlauf $19$ Trace Points und der $\Delta$-Wert gespeichert werden für $\lceil log_2(20) \rceil = 100$ Bit.

Die Abbildungen \ref{fig:diff-una} verdeutlicht, dass die unäre Kodierung Schwankungen im Bitverbrauch aufweist, welche sich wie bei den CIGAR-Strings durch die zufällig generierten Sequenzpaare erklären lassen, deren Alignments unter Umständen sehr viele oder ausschließlich Matches bzw. sehr viele InDels aufweisen können. Sie benötigt im Mittel $27$ Bit und damit nur etwa ein Viertel der binären Kodierung, was in Abbildung \ref{fig:diff-bin-una} grafisch dargestellt ist.

Für die Huffman-Kodierung wird, wie in Abbildung \ref{fig:diff-huf} zu sehen ist, deutlich weniger Speicher für die Kodierung benötigt als für die naive binäre oder unäre Kodierung. Sie verbraucht durchschnittlich nur 5 Bit und damit nur etwa ein Fünftel des Speicherbedarfs der unären Kodierung, was in \ref{fig:diff-una-huf} verdeutlicht wird.

Es ist somit zu erkennen, dass die Kodierung der Differenzen der Trace Points mit den oben genannten Parametern der Testläufe in allen Kodierungen weniger Speicher benötigt, als die Kodierung eines CIGAR-Strings, wobei die Huffman-Kodierung mit Abstand am effizientesten ist. Hierbei ist jedoch zu beachten, dass der Speicherverbrauch der Trace Point Kodierung von der Wahl des $\Delta$-Wertes abhängt, da bei einem kleinen $\Delta$ mehr Trace Points und somit mehr Symbole gespeichert werden müssen, als bei einem großen $\Delta$-Wert.