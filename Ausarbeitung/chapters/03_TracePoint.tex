\chapter{TracePoint Konzept}

Ein neuer Ansatz der speichereffizienten Repräsentation von Alignments wurde von Gene Myers in \cite{myers} beschrieben und basiert auf dem Konzept der Trace Points.

Sei $A$ ein Alignment von $u[i...j]$ und $v[k...\ell]$ mit $i < j$ und $k < l$ und sei $\Delta \in \mathbb{N}$. Sei $p = \left \lceil\frac{i}{\Delta}\right \rceil$. Man unterteilt $u[i...j]$ in $\tau = \left \lceil\frac{j}{\Delta}\right \rceil - \left \lfloor\frac{i}{\Delta}\right \rfloor$ Substrings $u_0, u_1, ... , u_{\tau -1}$ mit
\[  
u_q =
\begin{cases} 
u[i...p\cdot\Delta] & \text{falls }q = 0 \\
u[(p+q-1)\cdot\Delta+1...(p+q)\cdot\Delta] & \text{falls }0<q<\tau -1\\
u[(p+\tau-2)\cdot\Delta...j] & \text{falls }q = \tau -1
\end{cases}
\]

Für alle $q$ mit $ 0 \leq q < \tau -1$ sei $t_q$ der letzte Index des Substrings von $v$, der in A mit $u_q$ aligniert. $t_q$ nennt man Trace Point. Für $q = 0$ aligniert $u_0$ mit $v_0 = v[k...t_0]$. Für alle $q$ mit $0<q< \tau -1$ aligniert $u_q$ mit $v_q = v[t_{q-1}+1...t_q]$.

Seien $i,j,k,\ell,\Delta$ und die Trace-Points eines Alignments von $u$ und $v$ gegeben. Dann kann ein Alignment $A'$ von $u$ und $v$ mit $\delta (A') \leq \delta (A)$ konstruiert werden. Danach bestimmt man aus den Trace-Points die Substring-Paare $u_q$ und $v_q$, berechnet hierfür ein optimales Alignment und konkateniert die Alignments von den aufeinanderfolgenden Substring-Paaren zu $A'$.

Beispiel 2:
\begin{verbatim}
Sequenz 1: gagcatgttgcctggtcctttgctaggtactgtagaga
Sequenz 2: gaccaagtaggcgtggaccttgctcggtctgtaagaga
Delta: 15

Gesamtalignment:

0    5    0    5    0    5    0    5    0    
gagc-a-t-gttgcc-tggtcctttgctaggtactgta-gaga
|| | | | |  | | ||| |||| ||| ||| ||||| ||||
gaccaagtag--g-cgtggacctt-gctcggt-ctgtaagaga
0    5    0    5    0    5    0    5    0    



seq1[0...14] aligniert mit seq2[0...15]
gagc-a-t-gttgcc-tgg
|| | | | |  | | |||
gaccaagtag--g-cgtgg

seq1[15...29] aligniert mit seq2[16...28]
tcctttgctaggtac
 |||| ||| ||| |
acctt-gctcggt-c

seq1[30...37] aligniert mit seq2[29...37]
tgta-gaga
|||| ||||
tgtaagaga

Trace Points: [15, 28] 
\end{verbatim}

\section{Komplexität}

%TODO ausführlicher
 Für die Trace-Point Repräsentation wird für eine Edit-Distanz $e$ mit Einheitskosten als Kostenfunktion $\delta$ wie oben beschrieben lediglich $O(e^2)$ Zeit pro Teilalignment benötigt, wobei bei einer erwarteten Fehlerrate $\varepsilon$ des Alignments die Edit-Distanz immer höchstens so groß ist wie die Anzahl der Fehler im Teilalignment. \cite[S.41-42]{gsa-skript}
 
\section{Speicherverbrauch}

\subsection{Delta-Kodierung}\label{Delta-Kodierung}

%TODO
% L = (...)

\subsection{Beispiel}
Sei $\Delta = 5$ und das Alignment $A$
\begin{verbatim}
		0    5    0    5    0    5    0    5    0    
		gagc-a-t-gttgcc-tggtcctttgctaggtactgta-gaga
		|| | | | |  | | ||| |||| ||| ||| ||||| ||||
		gaccaagtag--g-cgtggacctt-gctcggt-ctgtaagaga
		0    5    0    5    0    5    0    5    0   
\end{verbatim}

wie in Abschnitt \ref{Cigar_Speicher} mit den dazugehörigen TracePoints $5, 10, 15, 20, 24, 28$ und $34$ gegeben. Es ergibt sich somit das Alphabet $\cal{A}$ $= \{5, 10, 15, 20, 24, 28, 34\}$ mit ausschließlich positiven und aufsteigenden Werten.

Für die Trace Point Darstellung ist somit eine Delta-Kodierung möglich. Als neue Liste zu kodierender Werte ergibt sich nach \ref{Delta-Kodierung} $L = (5, 5, 5, 4, 4, 6)$.

Um aus den Trace Points ein neues Alignment rekonstruieren zu können, benötigt man zusätzlich mindestens den $\Delta$-Wert, damit die Grenzen der Substrings beider Sequenzen berechnet werden können. Hierfür muss also der $\Delta$-Wert zu $L$ hinzugefügt werden.

Für das oben genannten Beispiel ergibt sich somit $L_\Delta = (5, 5, 5, 4, 4, 6, 5)$.

Sei das Alphabet $\cal{A}$ $= \{4, 5, 6\}$, sowie die relativen Wahrscheinlichkeiten $p(c)$ jeden Symbols $c \in$ $\cal{A}$ gegeben. 

\begin{table}[h]
	\centering
	\begin{tabular}{ccc}
		$c$&Häufigkeit&$p(c)$\\
		\hline
		$5$ & $4$ & $\frac{4}{7}$\\
		$4$ & $2$ & $\frac{2}{7}$\\
		$6$ & $1$ & $\frac{1}{7}$
	\end{tabular}
	\caption{Relative Wahrscheinlichkeiten der Delta-Kodierung}
\end{table}

Bei der naiven binären Kodierung ergibt sich analog zu \ref{Cigar_Speicher} ein Bedarf von $\lceil \log_2(7)\rceil = 3$ Bit pro Symbol, also $7 \cdot 3 = 21$ Bit insgesamt.

Die unäre Kodierung ergibt für dieses Beispiel die folgende Kodierung:

\begin{table}[h]
	\centering
	\begin{tabular}{ccr}
		Symbol & Kodierung &  Anzahl Bits\\
		\hline
		$5$ & $0$ & $4 \cdot 1 = 4$\\
		$4$ & $10$ & $2 \cdot 2 = 4$\\
		$6$ & $110$ & $1 \cdot 3 = 3$\\
		\hline
		\multicolumn{2}{l}{Gesamtanzahl:}&$11$
	\end{tabular}
	\caption{Unäre Kodierung der Delta-Kodierung}
\end{table}

Insgesamt benötigt die unäre Kodierung also $11$ Bit mit einem durchschnittlichen Verbrauch pro  Symbol von
\[\frac{11}{7} \approx 1.57 \text{ Bit.}\]

Die Ausführung des Huffman-Algorithmus ergibt nach \cite[S. 54]{coding}:

\begin{table}[h]
	\centering
	\begin{tabular}{ccr}
		Symbol & Kodierung & Anzahl Bits\\
		\hline
		$5$ & $0$ & $4 \cdot 1 = 4$\\
		$4$ & $10$ & $2 \cdot 2 = 4$\\
		$6$ & $11$ & $1 \cdot 2 = 2$\\
		\hline
		\multicolumn{2}{l}{Gesamtanzahl:}&$10$
	\end{tabular}
	\caption{Huffman-Kodierung der Delta-Kodierung}
\end{table}

und der dazugehörige Huffman-Baum:

\begin{figure}[h]
	\centering
	\begin{forest}
		for tree={grow'=south}
		[$\frac{7}{7}$
		[$\frac{3}{7}$, edge label={node[midway,right,font=\scriptsize]{1}}
		[$6$, edge label={node[midway,right,font=\scriptsize]{1}}]
		[$4$, edge label={node[midway,left,font=\scriptsize]{0}}]]
		[$5$, edge label={node[midway,left,font=\scriptsize]{0}}]
		]
	\end{forest}
	\caption{Huffman-Baum der Delta-Kodierung}
\end{figure}

Der gesamte Bitverbrauch der Huffman-Kodierung ist demnach $10$ Bit mit einem durchschnittlichen Verbrauch pro Symbol von 
\[\frac{10}{7} \approx 1.43 \text{ Bit.}\]

\subsection{Testläufe}

Die folgenden Grafiken wurden mit jeweils 100 zufällig generierte Sequenzpaaren mit je etwa 200 Basen, einer Fehlerrate von 15\% und einem $\Delta$-Wert von 10 berechnet.

\begin{filecontents*}{differences_binary.txt}
	1 95
	2 95
	3 95
	4 95
	5 95
	6 95
	7 95
	8 95
	9 95
	10 95
	11 95
	12 95
	13 95
	14 95
	15 95
	16 95
	17 95
	18 95
	19 95
	20 95
	21 95
	22 95
	23 95
	24 95
	25 95
	26 95
	27 95
	28 95
	29 95
	30 95
	31 95
	32 95
	33 95
	34 95
	35 95
	36 95
	37 95
	38 95
	39 95
	40 95
	41 95
	42 95
	43 95
	44 95
	45 95
	46 95
	47 95
	48 95
	49 95
	50 95
	51 95
	52 95
	53 95
	54 95
	55 95
	56 95
	57 95
	58 95
	59 95
	60 95
	61 95
	62 95
	63 95
	64 95
	65 95
	66 95
	67 95
	68 95
	69 95
	70 95
	71 95
	72 95
	73 95
	74 95
	75 95
	76 95
	77 95
	78 95
	79 95
	80 95
	81 95
	82 95
	83 95
	84 95
	85 95
	86 95
	87 95
	88 95
	89 95
	90 95
	91 95
	92 95
	93 95
	94 95
	95 95
	96 95
	97 95
	98 95
	99 95
	100 95
\end{filecontents*}

\begin{filecontents*}{differences_huffman.txt}
	1 5
	2 5
	3 5
	4 5
	5 5
	6 9
	7 5
	8 5
	9 5
	10 5
	11 5
	12 2
	13 5
	14 5
	15 2
	16 5
	17 5
	18 9
	19 5
	20 5
	21 14
	22 5
	23 5
	24 5
	25 9
	26 5
	27 9
	28 5
	29 2
	30 5
	31 14
	32 5
	33 5
	34 5
	35 5
	36 5
	37 5
	38 5
	39 5
	40 5
	41 5
	42 9
	43 5
	44 5
	45 2
	46 9
	47 5
	48 5
	49 9
	50 5
	51 9
	52 5
	53 5
	54 5
	55 9
	56 5
	57 5
	58 9
	59 2
	60 5
	61 5
	62 5
	63 5
	64 5
	65 5
	66 9
	67 2
	68 9
	69 9
	70 5
	71 2
	72 2
	73 9
	74 5
	75 5
	76 9
	77 5
	78 9
	79 2
	80 5
	81 5
	82 5
	83 5
	84 5
	85 9
	86 9
	87 9
	88 9
	89 5
	90 9
	91 5
	92 5
	93 5
	94 5
	95 5
	96 5
	97 5
	98 9
	99 5
	100 9
\end{filecontents*}

\begin{filecontents*}{differences_unary.txt}
	1 26
	2 28
	3 24
	4 23
	5 22
	6 27
	7 22
	8 23
	9 29
	10 20
	11 24
	12 23
	13 20
	14 26
	15 25
	16 23
	17 26
	18 23
	19 25
	20 30
	21 27
	22 26
	23 24
	24 25
	25 25
	26 26
	27 28
	28 28
	29 26
	30 24
	31 23
	32 23
	33 27
	34 25
	35 26
	36 36
	37 24
	38 25
	39 24
	40 21
	41 29
	42 22
	43 31
	44 30
	45 26
	46 26
	47 28
	48 27
	49 25
	50 25
	51 26
	52 32
	53 31
	54 23
	55 26
	56 29
	57 26
	58 29
	59 24
	60 30
	61 25
	62 32
	63 27
	64 24
	65 28
	66 23
	67 28
	68 23
	69 25
	70 23
	71 25
	72 22
	73 23
	74 28
	75 27
	76 25
	77 24
	78 23
	79 25
	80 25
	81 27
	82 32
	83 27
	84 27
	85 23
	86 31
	87 23
	88 21
	89 24
	90 21
	91 27
	92 31
	93 23
	94 25
	95 34
	96 26
	97 28
	98 26
	99 29
	100 28
\end{filecontents*}

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
	\begin{axis}[
	xlabel={Anzahl Durchläufe},
	ylabel={Anzahl Bits}]
	\addplot table {differences_binary.txt};
	\end{axis}
	\end{tikzpicture}
	\caption{Bitverbrauch der naiven binären Kodierung der Delta-Kodierung}
\end{figure}

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
	\begin{axis}[
	xlabel={Anzahl Durchläufe},
	ylabel={Anzahl Bits}]
	\addplot table {differences_unary.txt};
	\end{axis}
	\end{tikzpicture}
	\caption{Bitverbrauch der unären Kodierung der Delta-Kodierung}
\end{figure}
	
\begin{figure}[h]
	\centering
	\begin{tikzpicture}
	\begin{axis}[
	xlabel={Anzahl Durchläufe},
	ylabel={Anzahl Bits}]
	\addplot table {differences_huffman.txt};
	\end{axis}
	\end{tikzpicture}
	\caption{Bitverbrauch der Huffman-Kodierung der Delta-Kodierung}
\end{figure}
	
\begin{figure}[h]
	\centering
	\begin{tikzpicture}
	\begin{axis}[
	xlabel={Anzahl Durchläufe},
	ylabel={Anzahl Bits},
	legend pos=outer north east]
	\addplot table {differences_binary.txt};
	\addlegendentry{Binäre Kodierung};
	\addplot table {differences_unary.txt};
	\addlegendentry{Unäre Kodierung};
	\end{axis}
	\end{tikzpicture}
	\caption{Binäre und unäre Kodierung der Delta-Kodierung}
\end{figure}
	
\begin{figure}[h]
	\centering
	\begin{tikzpicture}
	\begin{axis}[
	xlabel={Anzahl Durchläufe},
	ylabel={Anzahl Bits},
	legend pos=outer north east]
	\addplot table {differences_unary.txt};
	\addlegendentry{Unäre Kodierung};
	\addplot table {differences_huffman.txt};
	\addlegendentry{Huffman-Kodierung};
	\end{axis}
	\end{tikzpicture}
	\caption{Unäre und Huffman-Kodierung der Delta-Kodierung}
\end{figure}

\section{Bewertung}
Die Repräsentation des Alignments $A$ benötigt als CIGAR-String mit einer naiven binären Kodierung $228$ Bit und als unäre Kodierung XX Bit, wobei die Kodierung der Trace Points mit $\Delta = 5$ mit einer naiven binären Kodierung $21$ Bit und als unäre Kodierung XX Bit benötigt.

Es ist somit zu erkennen, dass die Kodierung der Trace Points in diesem Fall mit einem relativ klein gewählten $\Delta$ weniger Speicher benötigt, als die Kodierung des CIGAR-Strings. Dennoch hängt der Speicherverbrauch der Trace Points Kodierung von der Wahl des $\Delta$ ab, da bei einem kleinen $\Delta$ mehr Trace Points und somit Symbole gespeichert werden müssen, als bei einem großen $\Delta$ und kann somit bei einer sehr ungünstig gewählten Größe mehr Speicher verbrauchen als ein CIGAR-String.

Je größer der vorher definierte positive Parameter $\Delta$ ist, desto weniger Trace-Points werden gespeichert und umso länger dauert die Berechnung, um die Teil-Alignments zu rekonstruieren. Bei einem kleinen $\Delta$ werden analog mehr Trace-Points gespeichert, aber die Rekonstruktionszeit der Teil-Alignments ist geringer.

Mithilfe von $\Delta$ lässt sich somit ein Trade-Off zwischen dem Speicherplatzverbrauch und dem Zeitbedarf für die Rekonstruktion der Teil-Alignments einstellen.
